Prompt: Analyze the LocalTube folder to understand its structure, purpose, and functionality. 
Follow these steps to study the codebase:

1. Read the README file to gain an overview of the project, its goals, and any setup instructions.

2. Examine the folder structure to understand how the files and directories are organized.

3. Identify the main entry point of the application (e.g., main.py, app.py, index.js) and start analyzing the code flow from there.

4. Study the dependencies and libraries used in the project to understand the external tools and frameworks being utilized.

5. Analyze the core functionality of the project by examining the key modules, classes, and functions.

6. Look for any configuration files (e.g., config.py, .env) to understand how the project is configured and what settings are available.

7. Investigate any tests or test directories to see how the project ensures code quality and handles different scenarios.

8. Review any documentation or inline comments to gather insights into the codebase and its intended behavior.

9. Identify any potential areas for improvement, optimization, or further exploration based on your analysis.

10. Provide a summary of your findings, including the project's purpose, key features, and any notable observations or recommendations.

Use the files and contents provided below to complete this analysis:


README:
README not found.

Folder Structure: LocalTube
.git/ [Ignored .git folder]
.gitignore [Skipped]
app.html
app.js
components/
downloader.js [Skipped]
downloads/
LocalTube_contents.txt [Skipped]
main.js [Skipped]
node_modules/
package-lock.json [Skipped]
package.json [Skipped]
pages/
styles.css [Skipped]
videoIndexer.js [Skipped]
pages\index.html [Skipped]
pages\index.js [Skipped]
pages\player.html [Skipped]
pages\player.js [Skipped]
pages\settings.html [Skipped]
pages\settings.js [Skipped]
components\header.html
components\header.js
components\video-player-manager.js [Skipped]


.git/ [Ignored .git folder]

File: app.html
Content:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LocalTube App</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdn.plyr.io/3.6.8/plyr.css">
</head>
<body >
    <!-- Header компонент -->
    <div id="header-component"></div>

    <div id="unified-player" class="unified-player minimized">
        <div class="player-wrapper">
            <video id="video-player" class="video-element"></video>
            <div class="player-controls minimized-controls">
                <button id="play-pause-btn" class="control-btn">⏯️</button>
                <button id="expand-btn" class="control-btn">⤢</button>
                <button id="close-btn" class="control-btn">✖️</button>
            </div>
        </div>
    </div>
    <!-- Контейнер для загрузки страниц -->
    <main id="page-content">
        
    </main>

    <!-- Download Modal компонент -->
    <div id="download-modal-component"></div>

    <!-- Скрипты -->
    <script src="app.js"></script>
</body>
</html>

File: app.js
Content:
const { ipcRenderer } = require('electron');
const path = require('path');
const fs = require('fs');
const Plyr = require('plyr');
const ffprobe = require('ffprobe-static');
const ffmpeg = require('fluent-ffmpeg');
const moment = require('moment');
let dragPlayer, dragPlayerEnd, toggleClickToPlayState

const VideoPlayerManager = require('./components/video-player-manager');
window.videoPlayerManager = new VideoPlayerManager();

const loadedScripts = {};
window.currentVideo = null;

// И добавьте функцию для установки текущего видео:
function setCurrentVideo(videoPath) {
    window.currentVideo = videoPath;
}

// Экспортируйте эту функцию:
window.appFunctions = {
    setCurrentVideo,
    loadPage
};

// Функция для загрузки HTML компонентов
async function loadComponent(id, componentPath) {
    try {
        const response = await fetch(componentPath);
        if (!response.ok) throw new Error(`Failed to fetch component at ${componentPath}`);
        const html = await response.text();
        document.getElementById(id).innerHTML = html;
    } catch (error) {
        console.error("Error loading component:", error);
    }
}

async function loadPage(pageName) {
    try {


        // Очищаем предыдущие ресурсы
        cleanupCurrentPage();
        
        const response = await fetch(`./pages/${pageName}.html`);
        if (!response.ok) throw new Error(`Failed to fetch page at ./pages/${pageName}.html`);
        const html = await response.text();
        document.getElementById("page-content").innerHTML = html;

        // Удаляем предыдущий скрипт
        if (loadedScripts[pageName]) {
            document.body.removeChild(loadedScripts[pageName]);
            delete loadedScripts[pageName];
        }

        const script = document.createElement('script');
        script.src = `./pages/${pageName}.js`;
        script.onload = () => {
            loadedScripts[pageName] = script;
        };
        document.body.appendChild(script);
    } catch (error) {
        console.error("Error loading page:", error);
    }
}

function cleanupCurrentPage() {
    // Очищаем все обработчики событий
    const pageContent = document.getElementById("page-content");
    const oldElement = pageContent.cloneNode(false);
    pageContent.parentNode.replaceChild(oldElement, pageContent);
    
    // Очищаем память от неиспользуемых ресурсов
    if (window.gc) window.gc();
}

// Инициализация приложения
// app.js - в функции initApp
async function initApp() {
    // Загрузка компонентов
    await loadComponent("header-component", "./components/header.html");

    // Загрузка начальной страницы
    await loadPage("index");

    if (!loadedScripts['header']) {
        const headerScript = document.createElement('script');
        headerScript.src = './components/header.js';
        headerScript.onload = () => {
            loadedScripts['header'] = headerScript;
        };
        document.body.appendChild(headerScript);
    }
    dragPlayer, dragPlayerEnd, toggleClickToPlayState = require('./components/header.js');
}



// Запуск инициализации после загрузки DOM
document.addEventListener("DOMContentLoaded", initApp);

// Обработчик для переключения страниц
ipcRenderer.on('navigate', (event, pageName) => {
    loadPage(pageName);
});


ipcRenderer.on('load-video', (event, videoPath) => {
    if (document.getElementById('video-player')) {
        // Если элемент плеера существует, отправляем событие загрузки видео
        document.dispatchEvent(new CustomEvent('video-ready-to-load', { detail: videoPath }));
    } else {
        // Если элемент плеера еще не создан, ждем его создания
        const checkInterval = setInterval(() => {
            if (document.getElementById('video-player')) {
                clearInterval(checkInterval);
                document.dispatchEvent(new CustomEvent('video-ready-to-load', { detail: videoPath }));
            }
        }, 100);
    }
});


File: components\header.html
Content:
<!-- components/header.html -->
<header>
    <div class="logo" id="logo" onclick="loadPage('index')">LocalTube</div>
    <div class="search-container">
        <input type="text" id="search" placeholder="Search videos...">
    </div>
    <div class="header-buttons">
        <div id="download-button" class="header-icon">⬇️</div>
        <div id="settings-button" class="header-icon" onclick="loadPage('settings')">⚙️</div>
        <label class="switch">
            <input type="checkbox" id="theme-toggle">
            <span class="slider round"></span>
        </label>
    </div>
    <script src="header.js"></script>
</header>

<div id="download-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <div class="tab-container">
                <button class="tab-button active" data-tab="download">Download Video</button>
                <button class="tab-button" data-tab="active">Active Downloads</button>
            </div>
            <span class="close">&times;</span>
        </div>

        <!-- Вкладка Download Video -->
        <div id="download-tab" class="tab-content active">
            <div class="modal-body">
                <div class="input-group">
                    <label for="video-url">YouTube URL:</label>
                    <input type="text" id="video-url" placeholder="https://www.youtube.com/watch?v=...">
                </div>
                <div id="quality-section" style="display: none;">
                    <label for="quality-select">Select Quality:</label>
                    <select id="quality-select"></select>
                </div>
                <div id="download-status"></div>
            </div>
            <div class="modal-footer">
                <button id="check-url" class="primary-button">Check Video</button>
                <button id="start-download" class="primary-button" style="display: none;">Download</button>
            </div>
        </div>

        <!-- Вкладка Active Downloads -->
        <div id="active-tab" class="tab-content">
            <div class="active-downloads-container">
                <div id="active-downloads-list">
                    <!-- Активные загрузки будут добавляться сюда динамически -->
                </div>
            </div>
        </div>
    </div>
</div>

File: components\header.js
Content:


const settingsButton = document.getElementById('settings-button');
const logoButton = document.getElementById('logo');
const themeToggle = document.getElementById('theme-toggle');
const searchInput = document.getElementById('search');
const downloadButton = document.getElementById('download-button');

const downloadModal = document.getElementById('download-modal');
const closeBtn = document.querySelector('.close');
const videoUrlInput = document.getElementById('video-url');
const qualitySelect = document.getElementById('quality-select');
const qualitySection = document.getElementById('quality-section');
const checkUrlBtn = document.getElementById('check-url');
const startDownloadBtn = document.getElementById('start-download');
const downloadStatus = document.getElementById('download-status');

window.playerState = {
    left: null,
    top: null,
    width: '320px',  // Дефолтные значения
    height: '180px',
    isMinimized: false,
    initialWidth: null,   
    initialHeight: null,  
    initialX: null,      
    initialY: null,
    element: null  
};

window.playerState = playerState;

let isDragging = false;
let isResizing =  false;
window.isDragging = isDragging;
window.isResizing = isResizing;


document.addEventListener('playerMinimizedChanged', function(e) {
    window.playerState.isMinimized = e.detail.isMinimized;
    if (window.playerState.isMinimized) {
        setupMinimizedPlayer();
    } else {
        resetMaximizedPlayer();
    }
});

function setupMinimizedPlayer() {
    const unifiedPlayer = document.getElementById('unified-player');
    const playerWrapper = unifiedPlayer.querySelector('.player-wrapper');
    const playPauseBtn = document.getElementById('play-pause-btn');
    const expandBtn = document.getElementById('expand-btn');
    const closeBtn = document.getElementById('close-btn');
    const resizeHandle = document.createElement('div');

    if (!window.currentVideo) return;

    window.playerState.isMinimized = true;
    window.playerState.element = document.getElementById('unified-player');

    toggleClickToPlay(false);

    // Если позиция не установлена, используем дефолтные значения
    if (window.playerState.left === null) {
        window.playerState.left = window.innerWidth - parseInt(window.playerState.width) - 20;
        window.playerState.top = window.innerHeight - parseInt(window.playerState.height) - 20;
    }

    // Применяем сохраненное состояние
    unifiedPlayer.style.left = `${window.playerState.left}px`;
    unifiedPlayer.style.top = `${window.playerState.top}px`;
    unifiedPlayer.style.width = window.playerState.width;
    unifiedPlayer.style.height = window.playerState.height;

    unifiedPlayer.classList.remove('maximized');
    unifiedPlayer.classList.add('minimized', 'visible');

    // Добавляем элемент для изменения размера
    resizeHandle.className = 'resize-handle';
    if (!unifiedPlayer.querySelector('.resize-handle')) {
        unifiedPlayer.appendChild(resizeHandle);
    }

    playPauseBtn.onclick = () => {
        if (window.globalPlayer.paused) {
            window.globalPlayer.play();
        } else {
            window.globalPlayer.pause();
        }
    };

    resizeHandle.onmousedown = resizeStart;
    playerWrapper.onmousedown = dragStart;
    document.onmousemove = handleMouseMove;
    document.onmouseup = handleMouseUp;

    // Обновляем обработчики кнопок
    expandBtn.onclick = () => {
        // Сохраняем текущее состояние для возможной последующей минимизации
        resetMaximizedPlayer();
        window.appFunctions.loadPage('player');
    };

    closeBtn.onclick = () => {
        unifiedPlayer.classList.remove('visible');
        window.globalPlayer.pause();
        resetMaximizedPlayer();
    };
}

function resizeStart(e) {
    if (!window.playerState.isMinimized) return;

    const unifiedPlayer = window.playerState.element;

    window.isResizing = true;
    window.playerState.initialWidth = unifiedPlayer.offsetWidth;
    window.playerState.initialHeight = unifiedPlayer.offsetHeight;
    window.playerState.initialX = e.clientX;
    window.playerState.initialY = e.clientY;

    console.error("isResizing set to: " + window.isResizing);

    unifiedPlayer.style.transition = 'none';
    e.stopPropagation();
}

// function resizeListener(e) {
//     console.error("HEY");
//     if (!window.playerState.isMinimized) return;
    
//     if (!isResizing) return;

//     const dx = e.clientX - initialX;
//     const dy = e.clientY - initialY;
    
//     const newWidth = Math.max(200, Math.min(initialWidth + dx, window.innerWidth - playerState.left));
//     const newHeight = Math.max(150, Math.min(initialHeight + dy, window.innerHeight - playerState.top));
    
//     // Сохраняем новый размер
//     playerState.width = `${newWidth}px`;
//     playerState.height = `${newHeight}px`;
    
//     unifiedPlayer.style.width = playerState.width;
//     unifiedPlayer.style.height = playerState.height;
// }

// function resizeEnd() {
//     if (!window.playerState.isMinimized) return;
    
//     isResizing = false;
//     isDragging = false;
//     unifiedPlayer.style.transition = '';
// }

function dragStart(e) {
    if (!window.playerState.isMinimized) return;
    if (e.target.closest('.player-controls') || e.target.closest('.resize-handle')) return;
    
    const unifiedPlayer = window.playerState.element;
    
    isDragging = true;
    const rect = unifiedPlayer.getBoundingClientRect();
    window.playerState.initialX = e.clientX - rect.left;
    window.playerState.initialY = e.clientY - rect.top;

    console.error("isDragging set to TRUE");
    
    unifiedPlayer.style.transition = 'none';
}

function resetMaximizedPlayer() {
    const unifiedPlayer = document.getElementById('unified-player');;
    const playerWrapper = unifiedPlayer.querySelector('.player-wrapper');

    toggleClickToPlay(true); 
    
    // Remove positioning and size styles
    unifiedPlayer.style.left = '';
    unifiedPlayer.style.top = '';
    unifiedPlayer.style.width = '';
    unifiedPlayer.style.height = '';
    
    // Remove event listeners
    
    playerWrapper.onmousedown = null;
    document.onmousemove = null;
    document.onmouseup = null;
    
    const resizeHandle = unifiedPlayer.querySelector('.resize-handle');
    if (resizeHandle) {
        resizeHandle.onmousedown = null;
        resizeHandle.remove();
    }
}

window.resetMaximizedPlayer = resetMaximizedPlayer;

// function drag(e) {
//     if (!isDragging || !window.playerState.isMinimized) return;
    
//     e.preventDefault();
    
//     const x = e.clientX - initialX;
//     const y = e.clientY - initialY;
    
//     const maxX = window.innerWidth - unifiedPlayer.offsetWidth;
//     const maxY = window.innerHeight - unifiedPlayer.offsetHeight;
    
//     const boundedX = Math.max(0, Math.min(x, maxX));
//     const boundedY = Math.max(0, Math.min(y, maxY));
    
//     // Сохраняем новую позицию
//     playerState.left = boundedX;
//     playerState.top = boundedY;
    
//     unifiedPlayer.style.left = `${boundedX}px`;
//     unifiedPlayer.style.top = `${boundedY}px`;
// }

function handleMouseMove(e) {
    const unifiedPlayer = playerState.element;
    
    if (!window.playerState.isMinimized) return;
    console.error("Kinda good _+ " + window.isResizing);
    if (!isDragging && !window.isResizing) return;
    
    
    if (window.isResizing) {
        // Используем переменные из playerState
        console.error("Kinda good");
        const dx = e.clientX - window.playerState.initialX;
        const dy = e.clientY - window.playerState.initialY;
        
        const newWidth = Math.max(200, Math.min(window.playerState.initialWidth + dx, window.innerWidth - window.playerState.left));
        const newHeight = Math.max(150, Math.min(window.playerState.initialHeight + dy, window.innerHeight - window.playerState.top));
        
        // Сохраняем новый размер
        window.playerState.width = `${newWidth}px`;
        window.playerState.height = `${newHeight}px`;
    
        window.playerState.element.style.width = playerState.width;
        window.playerState.element.style.height = playerState.height;
        console.error("Kinda good 2");
    } else if (isDragging) {
        // Drag logic
        const x = e.clientX - window.playerState.initialX;
        const y = e.clientY - window.playerState.initialY;
        
        const maxX = window.innerWidth - unifiedPlayer.offsetWidth;
        const maxY = window.innerHeight - unifiedPlayer.offsetHeight;
        
        const boundedX = Math.max(0, Math.min(x, maxX));
        const boundedY = Math.max(0, Math.min(y, maxY));
        
        window.playerState.left = boundedX;
        window.playerState.top = boundedY;
        
        unifiedPlayer.style.left = `${boundedX}px`;
        unifiedPlayer.style.top = `${boundedY}px`;
    }
}

// function dragEnd() {
//     if (!isDragging || !playerState.isMinimized) return;
//     isDragging = false;
//     unifiedPlayer.style.transition = ''; // Восстанавливаем transition
// }

function handleMouseUp() {
    if (!window.playerState.isMinimized) return;
    
    isDragging = false;
    window.isResizing = false;
    
    console.error("isResizing and isDragging set to FALSE");
    const unifiedPlayer = document.getElementById('unified-player');
    unifiedPlayer.style.transition = '';
}


function toggleClickToPlay(enable) {
    if (!window.globalPlayer) {
        console.log('Player not initialized');
        return;
    }

    const videoElement = window.globalPlayer.elements.container;
    if (enable) {
        videoElement.style.pointerEvents = 'auto';
    } else {
        videoElement.style.pointerEvents = 'none';
    }

    window.globalPlayer.config.clickToPlay = enable;
}



function toggleTheme() {
    document.body.classList.toggle('dark-theme');
    localStorage.setItem('dark-theme', document.body.classList.contains('dark-theme'));
}

if (localStorage.getItem('dark-theme') === 'true') {
    document.body.classList.add('dark-theme');
    themeToggle.checked = true;
}

themeToggle.addEventListener('change', toggleTheme);


let activeDownloads = new Map();

function initializeTabs() {
    const tabButtons = document.querySelectorAll('.tab-button');
    if (!tabButtons.length) return; // Exit if elements aren't found

    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            const tabId = button.dataset.tab;
            const tabContent = document.getElementById(`${tabId}-tab`);
            
            // Only proceed if we found the tab content
            if (!tabContent) {
                console.error(`Tab content not found for id: ${tabId}-tab`);
                return;
            }
            
            // Remove active class from all tabs and contents
            document.querySelectorAll('.tab-button').forEach(btn => 
                btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => 
                content.classList.remove('active'));
            
            // Add active class to selected tab and content
            button.classList.add('active');
            tabContent.classList.add('active');
        });
    });
}

document.addEventListener('DOMContentLoaded', initializeTabs);

async function initializeDownloads() {
    try {
        const downloads = await ipcRenderer.invoke('get-active-downloads');
        activeDownloads = new Map(downloads.map(d => [d.id, d]));
        updateActiveDownloadsList();
    } catch (error) {
        console.error('Failed to initialize downloads:', error);
    }
}


document.addEventListener('DOMContentLoaded', initializeDownloads);


ipcRenderer.on('download-update', (event, downloads) => {
    activeDownloads = new Map(downloads.map(d => [d.id, d]));
    updateActiveDownloadsList();
});

ipcRenderer.on('download-finished', (event, downloadId) => {
    const download = activeDownloads.get(downloadId);
    if (download) {
        showFinishedNotification(download);
        activeDownloads.delete(downloadId);
        updateActiveDownloadsList();
    }
});

function showFinishedNotification(download) {
    const status = document.getElementById('download-status');
    status.textContent = `Download completed: ${download.url}`;
    status.className = 'status-success';
}

function updateActiveDownloads() {
    ipcRenderer.invoke('get-active-downloads')
        .then(downloads => {
            activeDownloads = new Map(downloads);
            updateActiveDownloadsList();
        })
        .catch(error => {
            console.error('Failed to update active downloads:', error);
        });
}

function updateActiveDownloadsList() {
    const container = document.getElementById('active-downloads-list');
    container.innerHTML = '';
    
    activeDownloads.forEach((download, id) => {
        const item = createDownloadItemElement(download);
        container.appendChild(item);
    });
}


settingsButton.addEventListener('click', () => {
    ipcRenderer.send('open-settings');
});

logoButton.addEventListener('click', () => {
    if (window.currentVideo) {
        setupMinimizedPlayer();
    }
    ipcRenderer.send('index-videos');
});

searchInput.addEventListener('input', (e) => {
    const searchTerm = e.target.value.toLowerCase();
    const filteredVideos = allVideos.filter(video => 
        path.basename(video).toLowerCase().includes(searchTerm)
    );
    displayVideos(filteredVideos);
});

downloadButton.addEventListener('click', () => {
    downloadModal.style.display = 'block';
    videoUrlInput.focus();
    initializeTabs(); 
});

closeBtn.addEventListener('click', () => {
    downloadModal.style.display = 'none';
    resetModal();
});

window.addEventListener('click', (event) => {
    if (event.target === downloadModal) {
        downloadModal.style.display = 'none';
        resetModal();
    }
});

function resetModal() {
    videoUrlInput.value = '';
    qualitySection.style.display = 'none';
    startDownloadBtn.style.display = 'none';
    checkUrlBtn.style.display = 'block';
    downloadStatus.innerHTML = '';
    downloadStatus.className = '';
}
// Проверка информации о видео
checkUrlBtn.addEventListener('click', async () => {
    const url = videoUrlInput.value.trim();
    if (!url) {
        showStatus('Please enter a valid YouTube URL', 'error');
        return;
    }

    try {
        showStatus('Checking video information...', 'info');
        checkUrlBtn.disabled = true;

        const videoInfo = await ipcRenderer.invoke('get-video-info', url);
        qualitySelect.innerHTML = '';
        const qualities = videoInfo.qualities.video;

        Object.entries(qualities)
            .map(([id, info]) => ({
                id,
                label: `${info.height}p${info.fps > 30 ? info.fps : ''} ${info.dynamic_range}`,
                height: info.height
            }))
            .sort((a, b) => b.height - a.height)
            .forEach(quality => {
                const option = document.createElement('option');
                option.value = quality.id;
                option.textContent = quality.label;
                qualitySelect.appendChild(option);
            });

        qualitySection.style.display = 'block';
        startDownloadBtn.style.display = 'block';
        checkUrlBtn.style.display = 'none';
        showStatus('Select video quality and click Download', 'success');
    } catch (error) {
        showStatus(`Error: ${error.message}`, 'error');
    } finally {
        checkUrlBtn.disabled = false;
    }
});

// Начало загрузки видео
startDownloadBtn.addEventListener('click', async () => {
    const url = videoUrlInput.value.trim();
    const selectedQuality = qualitySelect.value;
    
    try {
        // Блокируем кнопку и показываем статус
        startDownloadBtn.disabled = true;
        const status = document.getElementById('download-status');
        status.textContent = 'Starting download...';
        status.className = 'status-info';
        
        //const result = await ipcRenderer.invoke('download-video', {
        //    videoUrl: url,
        //    videoFormat: selectedQuality,
        //    audioFormat: 'bestaudio'
        //});
        console.log("clicked");
        
        // Обновляем UI после успешной загрузки
        status.textContent = 'Download completed!';
        status.className = 'status-success';
        
    } catch (error) {
        const status = document.getElementById('download-status');
        status.textContent = `Error: ${error.message}`;
        status.className = 'status-error';
    } finally {
        startDownloadBtn.disabled = false;
    }
});

function showStatus(message, type) {
    downloadStatus.innerHTML = type === 'info' 
        ? `<div class="loading-spinner"></div>${message}`
        : message;
    downloadStatus.className = `status-${type}`;
}


document.querySelectorAll('.tab-button').forEach(button => {
    button.addEventListener('click', () => {
        const tabId = button.dataset.tab;
        
        // Переключаем активную вкладку
        document.querySelectorAll('.tab-button').forEach(btn => 
            btn.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(content => 
            content.classList.remove('active'));
        
        button.classList.add('active');
        document.getElementById(`${tabId}-tab`).classList.add('active');
    });
});

function addDownloadItem(videoInfo) {
    const downloadId = Date.now().toString();
    const downloadItem = createDownloadItemElement(downloadId, videoInfo);
    
    document.getElementById('active-downloads-list').appendChild(downloadItem);
    activeDownloads.set(downloadId, {
        status: 'pending',
        info: videoInfo
    });
    
    return downloadId;
}

function updateDownloadStatus(downloadId, status, progress) {
    const downloadItem = document.querySelector(`[data-download-id="${downloadId}"]`);
    if (downloadItem) {
        downloadItem.className = `download-item status-${status}`;
        const statusText = downloadItem.querySelector('.download-status');
        statusText.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        
        if (status === 'finished') {
            setTimeout(() => {
                downloadItem.remove();
                activeDownloads.delete(downloadId);
            }, 3000);
        }
    }
}

function createDownloadItemElement(download) {
    const div = document.createElement('div');
    div.className = `download-item status-${download.status}`;
    div.dataset.downloadId = download.id;
    
    div.innerHTML = `
        <div class="download-item-header">
            <div class="download-title">${download.url}</div>
            <div class="download-status">${download.status}</div>
        </div>
        <div class="download-progress-container">
            <div class="download-progress-bar"></div>
        </div>
    `;
    
    return div;
}

