Prompt: Analyze the LocalTube folder to understand its structure, purpose, and functionality. 
Follow these steps to study the codebase:

1. Read the README file to gain an overview of the project, its goals, and any setup instructions.

2. Examine the folder structure to understand how the files and directories are organized.

3. Identify the main entry point of the application (e.g., main.py, app.py, index.js) and start analyzing the code flow from there.

4. Study the dependencies and libraries used in the project to understand the external tools and frameworks being utilized.

5. Analyze the core functionality of the project by examining the key modules, classes, and functions.

6. Look for any configuration files (e.g., config.py, .env) to understand how the project is configured and what settings are available.

7. Investigate any tests or test directories to see how the project ensures code quality and handles different scenarios.

8. Review any documentation or inline comments to gather insights into the codebase and its intended behavior.

9. Identify any potential areas for improvement, optimization, or further exploration based on your analysis.

10. Provide a summary of your findings, including the project's purpose, key features, and any notable observations or recommendations.

Use the files and contents provided below to complete this analysis:


README:
README not found.

Folder Structure: LocalTube
.git/ [Ignored .git folder]
.gitignore [Skipped]
app.html
app.js
components/
downloader.js [Skipped]
downloads/
LocalTube_contents.txt [Skipped]
main.js
node_modules/
package-lock.json [Skipped]
package.json [Skipped]
pages/
styles.css [Skipped]
videoIndexer.js [Skipped]
pages\index.html
pages\index.js
pages\player.html
pages\player.js
pages\settings.html
pages\settings.js
node_modules\.bin [Ignored]
node_modules\.package-lock.json [Ignored]
node_modules\@electron [Ignored]
node_modules\@ffmpeg-installer [Ignored]
node_modules\@sec-ant [Ignored]
node_modules\@sindresorhus [Ignored]
node_modules\@szmarczak [Ignored]
node_modules\@tokenizer [Ignored]
node_modules\@types [Ignored]
node_modules\async [Ignored]
node_modules\base64-js [Ignored]
node_modules\boolean [Ignored]
node_modules\bops [Ignored]
node_modules\buffer-crc32 [Ignored]
node_modules\cacheable-lookup [Ignored]
node_modules\cacheable-request [Ignored]
node_modules\clone-response [Ignored]
node_modules\concat-stream [Ignored]
node_modules\content-type [Ignored]
node_modules\core-js [Ignored]
node_modules\custom-event-polyfill [Ignored]
node_modules\debug [Ignored]
node_modules\decompress-response [Ignored]
node_modules\defer-to-connect [Ignored]
node_modules\define-data-property [Ignored]
node_modules\define-properties [Ignored]
node_modules\detect-node [Ignored]
node_modules\duplexer [Ignored]
node_modules\electron [Ignored]
node_modules\end-of-stream [Ignored]
node_modules\env-paths [Ignored]
node_modules\es-define-property [Ignored]
node_modules\es-errors [Ignored]
node_modules\es6-error [Ignored]
node_modules\escape-string-regexp [Ignored]
node_modules\extract-zip [Ignored]
node_modules\fd-slicer [Ignored]
node_modules\ffmetadata [Ignored]
node_modules\ffmpeg-installer [Ignored]
node_modules\ffprobe-static [Ignored]
node_modules\file-type [Ignored]
node_modules\fluent-ffmpeg [Ignored]
node_modules\fs-extra [Ignored]
node_modules\function-bind [Ignored]
node_modules\get-intrinsic [Ignored]
node_modules\get-stream [Ignored]
node_modules\global-agent [Ignored]
node_modules\globalthis [Ignored]
node_modules\gopd [Ignored]
node_modules\got [Ignored]
node_modules\graceful-fs [Ignored]
node_modules\has-property-descriptors [Ignored]
node_modules\has-proto [Ignored]
node_modules\has-symbols [Ignored]
node_modules\hasown [Ignored]
node_modules\http-cache-semantics [Ignored]
node_modules\http2-wrapper [Ignored]
node_modules\ieee754 [Ignored]
node_modules\is-stream [Ignored]
node_modules\isexe [Ignored]
node_modules\json-buffer [Ignored]
node_modules\json-stringify-safe [Ignored]
node_modules\jsonfile [Ignored]
node_modules\keyv [Ignored]
node_modules\loadjs [Ignored]
node_modules\lowercase-keys [Ignored]
node_modules\matcher [Ignored]
node_modules\media-typer [Ignored]
node_modules\mimic-response [Ignored]
node_modules\moment [Ignored]
node_modules\mp4box [Ignored]
node_modules\ms [Ignored]
node_modules\music-metadata [Ignored]
node_modules\node-fetch [Ignored]
node_modules\node-ffmpeg-installer [Ignored]
node_modules\normalize-url [Ignored]
node_modules\object-keys [Ignored]
node_modules\once [Ignored]
node_modules\p-cancelable [Ignored]
node_modules\peek-readable [Ignored]
node_modules\pend [Ignored]
node_modules\plyr [Ignored]
node_modules\progress [Ignored]
node_modules\pump [Ignored]
node_modules\quick-lru [Ignored]
node_modules\rangetouch [Ignored]
node_modules\resolve-alpn [Ignored]
node_modules\responselike [Ignored]
node_modules\roarr [Ignored]
node_modules\semver [Ignored]
node_modules\semver-compare [Ignored]
node_modules\serialize-error [Ignored]
node_modules\split [Ignored]
node_modules\sprintf-js [Ignored]
node_modules\stream-combiner [Ignored]
node_modules\stream-filter [Ignored]
node_modules\strtok3 [Ignored]
node_modules\sumchecker [Ignored]
node_modules\through [Ignored]
node_modules\to-utf8 [Ignored]
node_modules\token-types [Ignored]
node_modules\tr46 [Ignored]
node_modules\type-fest [Ignored]
node_modules\uint8array-extras [Ignored]
node_modules\undici-types [Ignored]
node_modules\universalify [Ignored]
node_modules\url-polyfill [Ignored]
node_modules\webidl-conversions [Ignored]
node_modules\whatwg-url [Ignored]
node_modules\which [Ignored]
node_modules\wrappy [Ignored]
node_modules\yauzl [Ignored]
downloads\Delta_vs_John_Smith_anime_theeminenceinshadow_delta_johnsmith-1729702191528.mp4 [Ignored]
downloads\Elden_Ring_Shadow_Of_The_Erdtree_–_Messmer_The_Impaler_Boss_Fight_4k_60FPS-1729710526783.mp4 [Ignored]
downloads\Kai_Cenat_Reacts_To_Malenia_Phase_2_In_Elden_Ring!_😂-1729956431139.mp4 [Ignored]
downloads\Link_Click_-_Opening_2_4K_60FPS_VORTEX《时光代理人第二季》-_白鲨JAWS_Leaked_Version-1729896253333.mp4 [Ignored]
downloads\nokotan-1729695775460.mp4 [Ignored]
downloads\Okarun_Unlocks_Turbo_Granny_Power_-_DAN_DA_DAN-1729632953110.mp4 [Ignored]
downloads\Prvnci_blesses_the_culture_with_a_very_satisfying_kittyo-1729894096005.mp4 [Ignored]
downloads\SHINZO_WO_SASAGEYO!_ATTACK_ON_TITAN_Grissini_Project_Orchestra_(+_choristers)-1729982123932.mp4 [Ignored]
downloads\THE_SHATTERING_-_Elden_Ring_(If_I_Lose_It_All)-1729695547314.mp4 [Ignored]
downloads\video-1729622897850.mp4 [Ignored]
downloads\video-1729624295442.mp4 [Ignored]
downloads\video-1729624444843.mp4 [Ignored]
components\header.html
components\header.js


.git/ [Ignored .git folder]

File: app.html
Content:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LocalTube App</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdn.plyr.io/3.6.8/plyr.css">
</head>
<body >
    <!-- Header компонент -->
    <div id="header-component"></div>

    <!-- Контейнер для загрузки страниц -->
    <main id="page-content"></main>

    <!-- Download Modal компонент -->
    <div id="download-modal-component"></div>

    <!-- Скрипты -->
    <script src="app.js"></script>
</body>
</html>

File: app.js
Content:
const { ipcRenderer } = require('electron');
const path = require('path');
const fs = require('fs');
const Plyr = require('plyr');
const ffprobe = require('ffprobe-static');
const ffmpeg = require('fluent-ffmpeg');
const moment = require('moment');



const loadedScripts = {};
window.currentVideo = null;

// И добавьте функцию для установки текущего видео:
function setCurrentVideo(videoPath) {
    window.currentVideo = videoPath;
}

// Экспортируйте эту функцию:
window.appFunctions = {
    setCurrentVideo,
    loadPage
};

// Функция для загрузки HTML компонентов
async function loadComponent(id, componentPath) {
    try {
        const response = await fetch(componentPath);
        if (!response.ok) throw new Error(`Failed to fetch component at ${componentPath}`);
        const html = await response.text();
        document.getElementById(id).innerHTML = html;
    } catch (error) {
        console.error("Error loading component:", error);
    }
}

// Функция для загрузки страниц
async function loadPage(pageName) {
    try {
        const response = await fetch(`./pages/${pageName}.html`);
        if (!response.ok) throw new Error(`Failed to fetch page at ./pages/${pageName}.html`);
        const html = await response.text();
        document.getElementById("page-content").innerHTML = html;

        // Удаляем предыдущий скрипт страницы, если он существует
        if (loadedScripts[pageName]) {
            document.body.removeChild(loadedScripts[pageName]);
            delete loadedScripts[pageName];
        }

        // Динамическая загрузка соответствующего JavaScript файла
        const script = document.createElement('script');
        script.src = `./pages/${pageName}.js`;
        script.onload = () => {
            loadedScripts[pageName] = script;
        };
        document.body.appendChild(script);
    } catch (error) {
        console.error("Error loading page:", error);
    }
}

// Инициализация приложения
async function initApp() {
    // Загрузка компонентов
    await loadComponent("header-component", "./components/header.html");

    // Загрузка начальной страницы
    await loadPage("index");

    // Инициализация обработчиков событий для header
    if (!loadedScripts['header']) {
        const headerScript = document.createElement('script');
        headerScript.src = './components/header.js';
        headerScript.onload = () => {
            loadedScripts['header'] = headerScript;
        };
        document.body.appendChild(headerScript);
    }
}



// Запуск инициализации после загрузки DOM
document.addEventListener("DOMContentLoaded", initApp);

// Обработчик для переключения страниц
ipcRenderer.on('navigate', (event, pageName) => {
    loadPage(pageName);
});


ipcRenderer.on('load-video', (event, videoPath) => {
    if (document.getElementById('video-player')) {
        // Если элемент плеера существует, отправляем событие загрузки видео
        document.dispatchEvent(new CustomEvent('video-ready-to-load', { detail: videoPath }));
    } else {
        // Если элемент плеера еще не создан, ждем его создания
        const checkInterval = setInterval(() => {
            if (document.getElementById('video-player')) {
                clearInterval(checkInterval);
                document.dispatchEvent(new CustomEvent('video-ready-to-load', { detail: videoPath }));
            }
        }, 100);
    }
});

File: main.js
Content:
const { app, BrowserWindow, ipcMain, dialog } = require('electron');
const { indexVideos, addActiveDownload, removeActiveDownload } = require('./videoIndexer');
const path = require('path');
const fs = require('fs');

const VideoDownloader = require('./downloader');
const downloader = new VideoDownloader();

const activeDownloads = new Map();


let mainWindow;
let indexedFolders = [];

function createWindow() {
    mainWindow = new BrowserWindow({
        width: 1200,
        height: 800,
        webPreferences: {
            nodeIntegration: true,
            contextIsolation: false,
            enableRemoteModule: true,
            webSecurity: false,
            allowRunningInsecureContent: true
        }
    });

    mainWindow.setMenu(null);
    mainWindow.loadFile('app.html');
    mainWindow.webContents.openDevTools();
}

app.whenReady().then(() => {
    createWindow();

    app.on('activate', () => {
        if (BrowserWindow.getAllWindows().length === 0) {
            createWindow();
        }
    });

    // Load settings from settings.json
    const settingsPath = path.join(app.getPath('userData'), 'settings.json');
    if (fs.existsSync(settingsPath)) {
        indexedFolders = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));
    }
});

app.on('window-all-closed', () => {
    if (process.platform !== 'darwin') {
        app.quit();
    }
});

// Навигация между страницами
ipcMain.on('navigate', (event, pageName) => {
    mainWindow.webContents.send('navigate', pageName);
});

ipcMain.on('get-folders', (event) => {
    event.reply('load-folders', indexedFolders);
});

ipcMain.on('add-folder', (event) => {
    dialog.showOpenDialog({
        properties: ['openDirectory']
    }).then(result => {
        if (!result.canceled) {
            const newFolder = result.filePaths[0];
            if (!indexedFolders.includes(newFolder)) {
                indexedFolders.push(newFolder);
                saveSettings();
                event.reply('load-folders', indexedFolders);
            }
        }
    });
});

ipcMain.on('remove-folder', (event, folder) => {
    indexedFolders = indexedFolders.filter(f => f !== folder);
    saveSettings();
    event.reply('load-folders', indexedFolders);
});

ipcMain.on('index-videos', (event) => {
    const downloadPath = path.join(process.cwd(), 'downloads');
    const videos = indexVideos([downloadPath]);
    
    const filteredVideos = videos.filter(video => 
        !Array.from(activeDownloads.values()).some(download => 
            download.path === video
        )
    );
    
    event.reply('video-list', filteredVideos);
});

ipcMain.on('open-video', (event, videoPath) => {
    if (fs.existsSync(videoPath)) {
        mainWindow.webContents.send('navigate', 'player');
        // Используем setTimeout, чтобы дать время на загрузку страницы плеера
        setTimeout(() => {
            mainWindow.webContents.send('load-video', videoPath);
        }, 100);
    } else {
        mainWindow.webContents.send('video-not-found', videoPath);
    }
});

ipcMain.handle('get-video-info', async (event, videoUrl) => {
    try {
        return await downloader.getVideoInfo(videoUrl);
    } catch (error) {
        throw error;
    }
});

ipcMain.handle('download-video', async (event, { videoUrl, videoFormat, audioFormat }) => {
    try {
        const downloadId = Date.now().toString();
        const tempPath = path.join(app.getPath('temp'), `${downloadId}.mp4`);
        
        // Добавляем загрузку в активные
        activeDownloads.set(downloadId, {
            id: downloadId,
            url: videoUrl,
            status: 'pending',
            progress: 0,
            tempPath
        });
        
        // Сообщаем всем окнам об обновлении списка загрузок
        BrowserWindow.getAllWindows().forEach(win => {
            win.webContents.send('download-update', Array.from(activeDownloads.values()));
        });

        // Начинаем загрузку
        activeDownloads.get(downloadId).status = 'downloading';
        updateDownloadStatus(downloadId);
        
        const result = await downloader.downloadVideo(videoUrl, videoFormat, audioFormat);
        
        // Обновляем статус на добавление метаданных
        activeDownloads.get(downloadId).status = 'meta';
        updateDownloadStatus(downloadId);
        
        // После успешной загрузки
        activeDownloads.delete(downloadId);
        updateDownloadStatus(downloadId, true);
        
        return result;
    } catch (error) {
        throw error;
    }
});


function updateDownloadStatus(downloadId, finished = false) {
    BrowserWindow.getAllWindows().forEach(win => {
        if (finished) {
            win.webContents.send('download-finished', downloadId);
        } else {
            win.webContents.send('download-update', Array.from(activeDownloads.values()));
        }
    });
}

ipcMain.handle('get-active-downloads', () => {
    return Array.from(activeDownloads.values());
  });

function saveSettings() {
    const settingsPath = path.join(app.getPath('userData'), 'settings.json');
    fs.writeFileSync(settingsPath, JSON.stringify(indexedFolders, null, 2));
}

File: pages\index.html
Content:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LocalTube - Main Menu</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <main>
        <div class="video-container">
            <div id="video-grid" class="video-grid"></div>
        </div>
    </main>

    <!-- <script src="renderer.js"></script> -->

</body>
</html>


File: pages\index.js
Content:

(function() {
    console.log("Index page loaded");

    let videoGrid;
    let allVideos = [];
    const downloadPath = path.join(process.cwd(), 'downloads');

    function initIndex() {
        videoGrid = document.getElementById('video-grid');
        if (!videoGrid) {
            console.error('Video grid element not found');
            return;
        }

        ipcRenderer.send('index-videos');
    }

    function displayVideos(videos) {
        if (!videoGrid) return;

        videoGrid.innerHTML = '';
        if (videos.length === 0) {
            videoGrid.innerHTML = '<p>No videos found in the downloads folder.</p>';
            return;
        }
        
        const gridWrapper = document.createElement('div');
        gridWrapper.className = 'grid-wrapper';
        
        videos.forEach(videoPath => {
            if (!fs.existsSync(videoPath)) {
                return; // Пропускаем несуществующие файлы
            }

            const videoCard = createVideoCard(videoPath);
            gridWrapper.appendChild(videoCard);
        });
        
        videoGrid.appendChild(gridWrapper);
    }

    function createVideoCard(videoPath) {
        const videoCard = document.createElement('div');
        videoCard.className = 'video-card';

        const videoElement = document.createElement('video');
        videoElement.src = videoPath;
        videoElement.preload = 'metadata';
        videoElement.className = 'video-thumbnail';

        videoElement.addEventListener('loadedmetadata', () => {
            videoElement.currentTime = videoElement.duration / 3;
        });

        videoElement.addEventListener('seeked', () => {
            const canvas = document.createElement('canvas');
            canvas.width = videoElement.videoWidth;
            canvas.height = videoElement.videoHeight;
            canvas.getContext('2d').drawImage(videoElement, 0, 0, canvas.width, canvas.height);
            videoElement.poster = canvas.toDataURL();
        });

        const videoInfo = document.createElement('div');
        videoInfo.className = 'video-card-info';
        
        const title = path.basename(videoPath, path.extname(videoPath))
            .replace(/-\d+$/, '')
            .replace(/_/g, ' ');
            
        videoInfo.innerHTML = `
            <div class="video-card-title">${title}</div>
        `;

        videoCard.appendChild(videoElement);
        videoCard.appendChild(videoInfo);

        videoCard.addEventListener('click', (e) => {
            e.preventDefault();
            if (fs.existsSync(videoPath)) {
                window.appFunctions.setCurrentVideo(videoPath);
                window.appFunctions.loadPage('player');
            } else {
                alert('Video file not found');
                updateVideoList();
            }
        });

        return videoCard;
    }

    function updateVideoList() {
        if (fs.existsSync(downloadPath)) {
            ipcRenderer.send('index-videos');
        }
    }

    // Обработчики событий
    ipcRenderer.on('video-list', (event, videos) => {
        allVideos = videos.filter(video => fs.existsSync(video));
        displayVideos(allVideos);
    });

    ipcRenderer.on('video-download-complete', (event, videoPath) => {
        if (fs.existsSync(videoPath)) {
            setTimeout(updateVideoList, 1000);
        }
    });

    // Инициализация страницы
    initIndex();

    // Экспорт функций, которые могут понадобиться извне
    window.indexFunctions = {
        updateVideoList,
        displayVideos
    };
})();

File: pages\player.html
Content:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LocalTube - Video Player</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdn.plyr.io/3.6.8/plyr.css">
</head>
<body>

    <main class="main-player">
        <div class="video-container">
            <div id="player-container">
                <video id="video-player" controls></video>
            </div>
            <div class="video-info">
                <h1 id="video-title"></h1>
                <div id="video-meta"></div>
                <div class="actions">
                    <button id="like-button">Лайк</button>
                    <button id="dislike-button">Дизлайк</button>
                    <button id="share-button">Поделиться</button>
                </div>
                <div id="video-description">
                    <p id="description-text"></p>
                    <button id="show-more">Показать больше</button>
                </div>
            </div>
        </div>
        <div class="recommendations">
            <h2>Рекомендуемые видео</h2>
            <div id="video-list" class="video-list"></div>
        </div>
    </main>

    <script src="https://cdn.plyr.io/3.6.8/plyr.polyfilled.js"></script>
    <script src="player.js"></script>
</body>
</html>


File: pages\player.js
Content:
(function() {
    console.log("Player page loaded");

    let videoPlayer, videoTitle, videoMeta, descriptionText, showMoreBtn, backButton, player;

    function initPlayer() {
        videoPlayer = document.getElementById('video-player');
        videoTitle = document.getElementById('video-title');
        videoMeta = document.getElementById('video-meta');
        descriptionText = document.getElementById('description-text');
        showMoreBtn = document.getElementById('show-more');
        backButton = document.getElementById('back-button');

        // Plyr initialization
        player = new Plyr(videoPlayer, {
            controls: [
                'play-large', 'play', 'progress', 'current-time', 'mute', 'volume', 'captions', 'settings', 'pip', 'airplay', 'fullscreen'
            ],
            settings: ['captions', 'quality', 'speed', 'loop'],
            previewThumbnails: {
                enabled: false,
            }
        });

        // Загрузка текущего видео
        if (window.currentVideo) {
            filePath = window.currentVideo;
            videoPlayer.src = filePath;
            try {
                loadVideoMetadata(filePath);

                player.source = {
                    type: 'video',
                    sources: [{ src: filePath, type: 'video/mp4' }],
                };
               
                player.on('loadedmetadata', () => {
                    player.play().catch(error => {
                        console.error('Error auto-playing video:', error);
                    });
                });

            } catch (error) {
                console.error('Error loading video:', error);
            }
        } else {
            console.error('No video selected');
            // Можно добавить здесь логику для возврата на главную страницу
        }

        showMoreBtn.addEventListener('click', () => {
            const isExpanded = descriptionText.style.maxHeight;
            descriptionText.style.maxHeight = isExpanded ? null : `${descriptionText.scrollHeight}px`;
            showMoreBtn.textContent = isExpanded ? 'Show more' : 'Show less';
        });
    }

    async function loadVideo(filePath) {
        videoPlayer.src = filePath;
        try {
            await loadVideoMetadata(filePath);

            player.source = {
                type: 'video',
                sources: [{ src: filePath, type: 'video/mp4' }],
            };
           
            player.on('loadedmetadata', () => {
                player.play().catch(error => {
                    console.error('Error auto-playing video:', error);
                });
            });

        } catch (error) {
            console.error('Error loading video:', error);
        }
    }

    function loadVideoMetadata(filePath) {
        return new Promise((resolve, reject) => {
            ffmpeg.setFfprobePath(ffprobe.path);
            
            ffmpeg.ffprobe(filePath, (err, metadata) => {
                if (err) {
                    console.error('Error reading metadata:', err);
                    reject(err);
                    return;
                }

                try {
                    const videoStream = metadata.streams.find(stream => stream.codec_type === 'video');
                    
                    const title = path.basename(filePath, path.extname(filePath))
                        .replace(/-\d+$/, '')
                        .replace(/_/g, ' ');

                    videoTitle.textContent = title;
                    videoMeta.textContent = metadata.format.format_name || 'Unknown format';
                    descriptionText.textContent = 'No description available';

                    resolve({
                        title: title,
                        format: metadata.format.format_name || 'Unknown format'
                    });
                } catch (error) {
                    console.error('Error processing metadata:', error);
                    reject(error);
                }
            });
        });
    }

    function formatBitrate(bitrate) {
        if (!bitrate) return 'Unknown bitrate';
        return `${Math.round(bitrate / 1000)} kbps`;
    }

    // Инициализация плеера при загрузке страницы
    initPlayer();
})();

File: pages\settings.html
Content:

    <main>
        <h2>Indexed Folders</h2>
        <ul id="folder-list"></ul>
        <button id="add-folder">Add Folder</button>
        <label class="switch">
            <input type="checkbox" id="theme-toggle">
            <span class="slider round"></span>
        </label>
    </main>
    <script src="settings.js"></script>

File: pages\settings.js
Content:

const folderList = document.getElementById('folder-list');
const addFolderButton = document.getElementById('add-folder');
const backButton = document.getElementById('back-button');

themeToggle.addEventListener('change', toggleTheme);

// Загрузка сохраненных папок
ipcRenderer.on('load-folders', (event, folders) => {
    folderList.innerHTML = '';
    folders.forEach(folder => {
        const li = document.createElement('li');
        li.textContent = folder;
        const removeButton = document.createElement('button');
        removeButton.textContent = 'Remove';
        removeButton.onclick = () => ipcRenderer.send('remove-folder', folder);
        li.appendChild(removeButton);
        folderList.appendChild(li);
    });
});

addFolderButton.addEventListener('click', () => {
    ipcRenderer.send('add-folder');
});

backButton.addEventListener('click', () => {
    ipcRenderer.send('back-to-main');
});

ipcRenderer.send('get-folders');


node_modules\.bin [Ignored]

node_modules\.package-lock.json [Ignored]

node_modules\@electron [Ignored]

node_modules\@ffmpeg-installer [Ignored]

node_modules\@sec-ant [Ignored]

node_modules\@sindresorhus [Ignored]

node_modules\@szmarczak [Ignored]

node_modules\@tokenizer [Ignored]

node_modules\@types [Ignored]

node_modules\async [Ignored]

node_modules\base64-js [Ignored]

node_modules\boolean [Ignored]

node_modules\bops [Ignored]

node_modules\buffer-crc32 [Ignored]

node_modules\cacheable-lookup [Ignored]

node_modules\cacheable-request [Ignored]

node_modules\clone-response [Ignored]

node_modules\concat-stream [Ignored]

node_modules\content-type [Ignored]

node_modules\core-js [Ignored]

node_modules\custom-event-polyfill [Ignored]

node_modules\debug [Ignored]

node_modules\decompress-response [Ignored]

node_modules\defer-to-connect [Ignored]

node_modules\define-data-property [Ignored]

node_modules\define-properties [Ignored]

node_modules\detect-node [Ignored]

node_modules\duplexer [Ignored]

node_modules\electron [Ignored]

node_modules\end-of-stream [Ignored]

node_modules\env-paths [Ignored]

node_modules\es-define-property [Ignored]

node_modules\es-errors [Ignored]

node_modules\es6-error [Ignored]

node_modules\escape-string-regexp [Ignored]

node_modules\extract-zip [Ignored]

node_modules\fd-slicer [Ignored]

node_modules\ffmetadata [Ignored]

node_modules\ffmpeg-installer [Ignored]

node_modules\ffprobe-static [Ignored]

node_modules\file-type [Ignored]

node_modules\fluent-ffmpeg [Ignored]

node_modules\fs-extra [Ignored]

node_modules\function-bind [Ignored]

node_modules\get-intrinsic [Ignored]

node_modules\get-stream [Ignored]

node_modules\global-agent [Ignored]

node_modules\globalthis [Ignored]

node_modules\gopd [Ignored]

node_modules\got [Ignored]

node_modules\graceful-fs [Ignored]

node_modules\has-property-descriptors [Ignored]

node_modules\has-proto [Ignored]

node_modules\has-symbols [Ignored]

node_modules\hasown [Ignored]

node_modules\http-cache-semantics [Ignored]

node_modules\http2-wrapper [Ignored]

node_modules\ieee754 [Ignored]

node_modules\is-stream [Ignored]

node_modules\isexe [Ignored]

node_modules\json-buffer [Ignored]

node_modules\json-stringify-safe [Ignored]

node_modules\jsonfile [Ignored]

node_modules\keyv [Ignored]

node_modules\loadjs [Ignored]

node_modules\lowercase-keys [Ignored]

node_modules\matcher [Ignored]

node_modules\media-typer [Ignored]

node_modules\mimic-response [Ignored]

node_modules\moment [Ignored]

node_modules\mp4box [Ignored]

node_modules\ms [Ignored]

node_modules\music-metadata [Ignored]

node_modules\node-fetch [Ignored]

node_modules\node-ffmpeg-installer [Ignored]

node_modules\normalize-url [Ignored]

node_modules\object-keys [Ignored]

node_modules\once [Ignored]

node_modules\p-cancelable [Ignored]

node_modules\peek-readable [Ignored]

node_modules\pend [Ignored]

node_modules\plyr [Ignored]

node_modules\progress [Ignored]

node_modules\pump [Ignored]

node_modules\quick-lru [Ignored]

node_modules\rangetouch [Ignored]

node_modules\resolve-alpn [Ignored]

node_modules\responselike [Ignored]

node_modules\roarr [Ignored]

node_modules\semver [Ignored]

node_modules\semver-compare [Ignored]

node_modules\serialize-error [Ignored]

node_modules\split [Ignored]

node_modules\sprintf-js [Ignored]

node_modules\stream-combiner [Ignored]

node_modules\stream-filter [Ignored]

node_modules\strtok3 [Ignored]

node_modules\sumchecker [Ignored]

node_modules\through [Ignored]

node_modules\to-utf8 [Ignored]

node_modules\token-types [Ignored]

node_modules\tr46 [Ignored]

node_modules\type-fest [Ignored]

node_modules\uint8array-extras [Ignored]

node_modules\undici-types [Ignored]

node_modules\universalify [Ignored]

node_modules\url-polyfill [Ignored]

node_modules\webidl-conversions [Ignored]

node_modules\whatwg-url [Ignored]

node_modules\which [Ignored]

node_modules\wrappy [Ignored]

node_modules\yauzl [Ignored]

downloads\Delta_vs_John_Smith_anime_theeminenceinshadow_delta_johnsmith-1729702191528.mp4 [Ignored]

downloads\Elden_Ring_Shadow_Of_The_Erdtree_–_Messmer_The_Impaler_Boss_Fight_4k_60FPS-1729710526783.mp4 [Ignored]

downloads\Kai_Cenat_Reacts_To_Malenia_Phase_2_In_Elden_Ring!_😂-1729956431139.mp4 [Ignored]

downloads\Link_Click_-_Opening_2_4K_60FPS_VORTEX《时光代理人第二季》-_白鲨JAWS_Leaked_Version-1729896253333.mp4 [Ignored]

downloads\nokotan-1729695775460.mp4 [Ignored]

downloads\Okarun_Unlocks_Turbo_Granny_Power_-_DAN_DA_DAN-1729632953110.mp4 [Ignored]

downloads\Prvnci_blesses_the_culture_with_a_very_satisfying_kittyo-1729894096005.mp4 [Ignored]

downloads\SHINZO_WO_SASAGEYO!_ATTACK_ON_TITAN_Grissini_Project_Orchestra_(+_choristers)-1729982123932.mp4 [Ignored]

downloads\THE_SHATTERING_-_Elden_Ring_(If_I_Lose_It_All)-1729695547314.mp4 [Ignored]

downloads\video-1729622897850.mp4 [Ignored]

downloads\video-1729624295442.mp4 [Ignored]

downloads\video-1729624444843.mp4 [Ignored]

File: components\header.html
Content:
<!-- components/header.html -->
<header>
    <div class="logo" id="logo" onclick="loadPage('index')">LocalTube</div>
    <div class="search-container">
        <input type="text" id="search" placeholder="Search videos...">
    </div>
    <div class="header-buttons">
        <div id="download-button" class="header-icon">⬇️</div>
        <div id="settings-button" class="header-icon" onclick="loadPage('settings')">⚙️ Settings</div>
        <label class="switch">
            <input type="checkbox" id="theme-toggle">
            <span class="slider round"></span>
        </label>
    </div>
    <script src="header.js"></script>
</header>

<div id="download-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <div class="tab-container">
                <button class="tab-button active" data-tab="download">Download Video</button>
                <button class="tab-button" data-tab="active">Active Downloads</button>
            </div>
            <span class="close">&times;</span>
        </div>

        <!-- Вкладка Download Video -->
        <div id="download-tab" class="tab-content active">
            <div class="modal-body">
                <div class="input-group">
                    <label for="video-url">YouTube URL:</label>
                    <input type="text" id="video-url" placeholder="https://www.youtube.com/watch?v=...">
                </div>
                <div id="quality-section" style="display: none;">
                    <label for="quality-select">Select Quality:</label>
                    <select id="quality-select"></select>
                </div>
                <div id="download-status"></div>
            </div>
            <div class="modal-footer">
                <button id="check-url" class="primary-button">Check Video</button>
                <button id="start-download" class="primary-button" style="display: none;">Download</button>
            </div>
        </div>

        <!-- Вкладка Active Downloads -->
        <div id="active-tab" class="tab-content">
            <div class="active-downloads-container">
                <div id="active-downloads-list">
                    <!-- Активные загрузки будут добавляться сюда динамически -->
                </div>
            </div>
        </div>
    </div>
</div>

File: components\header.js
Content:

const settingsButton = document.getElementById('settings-button');
const logoButton = document.getElementById('logo');
const themeToggle = document.getElementById('theme-toggle');
const searchInput = document.getElementById('search');
const downloadButton = document.getElementById('download-button');

const downloadModal = document.getElementById('download-modal');
const closeBtn = document.querySelector('.close');
const videoUrlInput = document.getElementById('video-url');
const qualitySelect = document.getElementById('quality-select');
const qualitySection = document.getElementById('quality-section');
const checkUrlBtn = document.getElementById('check-url');
const startDownloadBtn = document.getElementById('start-download');
const downloadStatus = document.getElementById('download-status');


function toggleTheme() {
    document.body.classList.toggle('dark-theme');
    localStorage.setItem('dark-theme', document.body.classList.contains('dark-theme'));
}

if (localStorage.getItem('dark-theme') === 'true') {
    document.body.classList.add('dark-theme');
    themeToggle.checked = true;
}

themeToggle.addEventListener('change', toggleTheme);


let activeDownloads = new Map();

function initializeTabs() {
    const tabButtons = document.querySelectorAll('.tab-button');
    if (!tabButtons.length) return; // Exit if elements aren't found

    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            const tabId = button.dataset.tab;
            const tabContent = document.getElementById(`${tabId}-tab`);
            
            // Only proceed if we found the tab content
            if (!tabContent) {
                console.error(`Tab content not found for id: ${tabId}-tab`);
                return;
            }
            
            // Remove active class from all tabs and contents
            document.querySelectorAll('.tab-button').forEach(btn => 
                btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => 
                content.classList.remove('active'));
            
            // Add active class to selected tab and content
            button.classList.add('active');
            tabContent.classList.add('active');
        });
    });
}

document.addEventListener('DOMContentLoaded', initializeTabs);

async function initializeDownloads() {
    try {
        const downloads = await ipcRenderer.invoke('get-active-downloads');
        activeDownloads = new Map(downloads.map(d => [d.id, d]));
        updateActiveDownloadsList();
    } catch (error) {
        console.error('Failed to initialize downloads:', error);
    }
}


document.addEventListener('DOMContentLoaded', initializeDownloads);


ipcRenderer.on('download-update', (event, downloads) => {
    activeDownloads = new Map(downloads.map(d => [d.id, d]));
    updateActiveDownloadsList();
});

ipcRenderer.on('download-finished', (event, downloadId) => {
    const download = activeDownloads.get(downloadId);
    if (download) {
        showFinishedNotification(download);
        activeDownloads.delete(downloadId);
        updateActiveDownloadsList();
    }
});

function showFinishedNotification(download) {
    const status = document.getElementById('download-status');
    status.textContent = `Download completed: ${download.url}`;
    status.className = 'status-success';
}

function updateActiveDownloads() {
    ipcRenderer.invoke('get-active-downloads')
        .then(downloads => {
            activeDownloads = new Map(downloads);
            updateActiveDownloadsList();
        })
        .catch(error => {
            console.error('Failed to update active downloads:', error);
        });
}

function updateActiveDownloadsList() {
    const container = document.getElementById('active-downloads-list');
    container.innerHTML = '';
    
    activeDownloads.forEach((download, id) => {
        const item = createDownloadItemElement(download);
        container.appendChild(item);
    });
}


settingsButton.addEventListener('click', () => {
    ipcRenderer.send('open-settings');
});

logoButton.addEventListener('click', () => {
    ipcRenderer.send('index-videos');
});

searchInput.addEventListener('input', (e) => {
    const searchTerm = e.target.value.toLowerCase();
    const filteredVideos = allVideos.filter(video => 
        path.basename(video).toLowerCase().includes(searchTerm)
    );
    displayVideos(filteredVideos);
});

downloadButton.addEventListener('click', () => {
    downloadModal.style.display = 'block';
    videoUrlInput.focus();
    initializeTabs(); 
});

closeBtn.addEventListener('click', () => {
    downloadModal.style.display = 'none';
    resetModal();
});

window.addEventListener('click', (event) => {
    if (event.target === downloadModal) {
        downloadModal.style.display = 'none';
        resetModal();
    }
});

function resetModal() {
    videoUrlInput.value = '';
    qualitySection.style.display = 'none';
    startDownloadBtn.style.display = 'none';
    checkUrlBtn.style.display = 'block';
    downloadStatus.innerHTML = '';
    downloadStatus.className = '';
}
// Проверка информации о видео
checkUrlBtn.addEventListener('click', async () => {
    const url = videoUrlInput.value.trim();
    if (!url) {
        showStatus('Please enter a valid YouTube URL', 'error');
        return;
    }

    try {
        showStatus('Checking video information...', 'info');
        checkUrlBtn.disabled = true;

        const videoInfo = await ipcRenderer.invoke('get-video-info', url);
        qualitySelect.innerHTML = '';
        const qualities = videoInfo.qualities.video;

        Object.entries(qualities)
            .map(([id, info]) => ({
                id,
                label: `${info.height}p${info.fps > 30 ? info.fps : ''} ${info.dynamic_range}`,
                height: info.height
            }))
            .sort((a, b) => b.height - a.height)
            .forEach(quality => {
                const option = document.createElement('option');
                option.value = quality.id;
                option.textContent = quality.label;
                qualitySelect.appendChild(option);
            });

        qualitySection.style.display = 'block';
        startDownloadBtn.style.display = 'block';
        checkUrlBtn.style.display = 'none';
        showStatus('Select video quality and click Download', 'success');
    } catch (error) {
        showStatus(`Error: ${error.message}`, 'error');
    } finally {
        checkUrlBtn.disabled = false;
    }
});

// Начало загрузки видео
startDownloadBtn.addEventListener('click', async () => {
    const url = videoUrlInput.value.trim();
    const selectedQuality = qualitySelect.value;
    
    try {
        // Блокируем кнопку и показываем статус
        startDownloadBtn.disabled = true;
        const status = document.getElementById('download-status');
        status.textContent = 'Starting download...';
        status.className = 'status-info';
        
        const result = await ipcRenderer.invoke('download-video', {
            videoUrl: url,
            videoFormat: selectedQuality,
            audioFormat: 'bestaudio'
        });
        
        // Обновляем UI после успешной загрузки
        status.textContent = 'Download completed!';
        status.className = 'status-success';
        
        // Переключаемся на вкладку активных загрузок
        document.querySelector('[data-tab="active"]').click();
        
    } catch (error) {
        const status = document.getElementById('download-status');
        status.textContent = `Error: ${error.message}`;
        status.className = 'status-error';
    } finally {
        startDownloadBtn.disabled = false;
    }
});

function showStatus(message, type) {
    downloadStatus.innerHTML = type === 'info' 
        ? `<div class="loading-spinner"></div>${message}`
        : message;
    downloadStatus.className = `status-${type}`;
}


document.querySelectorAll('.tab-button').forEach(button => {
    button.addEventListener('click', () => {
        const tabId = button.dataset.tab;
        
        // Переключаем активную вкладку
        document.querySelectorAll('.tab-button').forEach(btn => 
            btn.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(content => 
            content.classList.remove('active'));
        
        button.classList.add('active');
        document.getElementById(`${tabId}-tab`).classList.add('active');
    });
});

function addDownloadItem(videoInfo) {
    const downloadId = Date.now().toString();
    const downloadItem = createDownloadItemElement(downloadId, videoInfo);
    
    document.getElementById('active-downloads-list').appendChild(downloadItem);
    activeDownloads.set(downloadId, {
        status: 'pending',
        info: videoInfo
    });
    
    return downloadId;
}

function updateDownloadStatus(downloadId, status, progress) {
    const downloadItem = document.querySelector(`[data-download-id="${downloadId}"]`);
    if (downloadItem) {
        downloadItem.className = `download-item status-${status}`;
        const statusText = downloadItem.querySelector('.download-status');
        statusText.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        
        if (status === 'finished') {
            setTimeout(() => {
                downloadItem.remove();
                activeDownloads.delete(downloadId);
            }, 3000);
        }
    }
}

function createDownloadItemElement(download) {
    const div = document.createElement('div');
    div.className = `download-item status-${download.status}`;
    div.dataset.downloadId = download.id;
    
    div.innerHTML = `
        <div class="download-item-header">
            <div class="download-title">${download.url}</div>
            <div class="download-status">${download.status}</div>
        </div>
        <div class="download-progress-container">
            <div class="download-progress-bar"></div>
        </div>
    `;
    
    return div;
}

