Prompt: Analyze the LocalTube folder to understand its structure, purpose, and functionality. 
Follow these steps to study the codebase:

1. Read the README file to gain an overview of the project, its goals, and any setup instructions.

2. Examine the folder structure to understand how the files and directories are organized.

3. Identify the main entry point of the application (e.g., main.py, app.py, index.js) and start analyzing the code flow from there.

4. Study the dependencies and libraries used in the project to understand the external tools and frameworks being utilized.

5. Analyze the core functionality of the project by examining the key modules, classes, and functions.

6. Look for any configuration files (e.g., config.py, .env) to understand how the project is configured and what settings are available.

7. Investigate any tests or test directories to see how the project ensures code quality and handles different scenarios.

8. Review any documentation or inline comments to gather insights into the codebase and its intended behavior.

9. Identify any potential areas for improvement, optimization, or further exploration based on your analysis.

10. Provide a summary of your findings, including the project's purpose, key features, and any notable observations or recommendations.

Use the files and contents provided below to complete this analysis:


README:
README not found.

Folder Structure: LocalTube
.git/ [Ignored .git folder]
.gitignore [Skipped]
app.html
app.js
components/
downloader.js [Skipped]
downloads/
LocalTube_contents.txt [Skipped]
main.js [Skipped]
node_modules/
package-lock.json [Skipped]
package.json [Skipped]
pages/
styles.css [Skipped]
videoIndexer.js [Skipped]
pages\index.html [Skipped]
pages\index.js [Skipped]
pages\player.html
pages\player.js
pages\settings.html [Skipped]
pages\settings.js [Skipped]
components\header.js
components\video-player-manager.js


.git/ [Ignored .git folder]

File: app.html
Content:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LocalTube App</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdn.plyr.io/3.6.8/plyr.css">
</head>
<body >
    <!-- Header компонент -->
    <div id="header-component"></div>

    <div id="unified-player" class="unified-player minimized">
        <div class="player-wrapper">
            <video id="video-player" class="video-element"></video>
            <div class="player-controls minimized-controls">
                <button id="play-pause-btn" class="control-btn">⏯️</button>
                <button id="expand-btn" class="control-btn">⤢</button>
                <button id="close-btn" class="control-btn">✖️</button>
            </div>
        </div>
    </div>
    <!-- Контейнер для загрузки страниц -->
    <main id="page-content"></main>

    <!-- Download Modal компонент -->
    <div id="download-modal-component"></div>

    <!-- Скрипты -->
    <script src="app.js"></script>
</body>
</html>

File: app.js
Content:
const { ipcRenderer } = require('electron');
const path = require('path');
const fs = require('fs');
const Plyr = require('plyr');
const ffprobe = require('ffprobe-static');
const ffmpeg = require('fluent-ffmpeg');
const moment = require('moment');


const VideoPlayerManager = require('./components/video-player-manager');
window.videoPlayerManager = new VideoPlayerManager();

const loadedScripts = {};
window.currentVideo = null;

// И добавьте функцию для установки текущего видео:
function setCurrentVideo(videoPath) {
    window.currentVideo = videoPath;
}

// Экспортируйте эту функцию:
window.appFunctions = {
    setCurrentVideo,
    loadPage
};

// Функция для загрузки HTML компонентов
async function loadComponent(id, componentPath) {
    try {
        const response = await fetch(componentPath);
        if (!response.ok) throw new Error(`Failed to fetch component at ${componentPath}`);
        const html = await response.text();
        document.getElementById(id).innerHTML = html;
    } catch (error) {
        console.error("Error loading component:", error);
    }
}

async function loadPage(pageName) {
    try {


        // Очищаем предыдущие ресурсы
        cleanupCurrentPage();
        
        const response = await fetch(`./pages/${pageName}.html`);
        if (!response.ok) throw new Error(`Failed to fetch page at ./pages/${pageName}.html`);
        const html = await response.text();
        document.getElementById("page-content").innerHTML = html;

        // Удаляем предыдущий скрипт
        if (loadedScripts[pageName]) {
            document.body.removeChild(loadedScripts[pageName]);
            delete loadedScripts[pageName];
        }

        const script = document.createElement('script');
        script.src = `./pages/${pageName}.js`;
        script.onload = () => {
            loadedScripts[pageName] = script;
        };
        document.body.appendChild(script);
    } catch (error) {
        console.error("Error loading page:", error);
    }
}

function cleanupCurrentPage() {
    // Очищаем все обработчики событий
    const pageContent = document.getElementById("page-content");
    const oldElement = pageContent.cloneNode(false);
    pageContent.parentNode.replaceChild(oldElement, pageContent);
    
    // Очищаем память от неиспользуемых ресурсов
    if (window.gc) window.gc();
}

// Инициализация приложения
// app.js - в функции initApp
async function initApp() {
    // Загрузка компонентов
    await loadComponent("header-component", "./components/header.html");
    await loadComponent("floating-player-component", "./components/floating-player.html");

    // Загрузка начальной страницы
    await loadPage("index");

    if (!loadedScripts['header']) {
        const headerScript = document.createElement('script');
        headerScript.src = './components/header.js';
        headerScript.onload = () => {
            loadedScripts['header'] = headerScript;
        };
        document.body.appendChild(headerScript);
    }
}



// Запуск инициализации после загрузки DOM
document.addEventListener("DOMContentLoaded", initApp);

// Обработчик для переключения страниц
ipcRenderer.on('navigate', (event, pageName) => {
    loadPage(pageName);
});


ipcRenderer.on('load-video', (event, videoPath) => {
    if (document.getElementById('video-player')) {
        // Если элемент плеера существует, отправляем событие загрузки видео
        document.dispatchEvent(new CustomEvent('video-ready-to-load', { detail: videoPath }));
    } else {
        // Если элемент плеера еще не создан, ждем его создания
        const checkInterval = setInterval(() => {
            if (document.getElementById('video-player')) {
                clearInterval(checkInterval);
                document.dispatchEvent(new CustomEvent('video-ready-to-load', { detail: videoPath }));
            }
        }, 100);
    }
});

File: pages\player.html
Content:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LocalTube - Video Player</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdn.plyr.io/3.6.8/plyr.css">
</head>
<body>

    <main class="main-player">
        <div class="video-container">
            <div id="player-container">
                <video id="video-player" controls></video>
            </div>
            <div class="video-info">
                <h1 id="video-title"></h1>
                <div id="video-meta"></div>
                <div class="actions">
                    <button id="like-button">Лайк</button>
                    <button id="dislike-button">Дизлайк</button>
                    <button id="share-button">Поделиться</button>
                </div>
                <div id="video-description">
                    <p id="description-text"></p>
                    <button id="show-more">Показать больше</button>
                </div>
            </div>
        </div>
        <div class="recommendations">
            <h2>Рекомендуемые видео</h2>
            <div id="video-list" class="video-list"></div>
        </div>
    </main>

    <script src="https://cdn.plyr.io/3.6.8/plyr.polyfilled.js"></script>
    <script src="player.js"></script>
</body>
</html>


File: pages\player.js
Content:
(function() {
    console.log("Player page loaded");

    let videoPlayer, videoTitle, videoMeta, descriptionText, showMoreBtn, player;
    const unifiedPlayer = document.getElementById('unified-player');
    
    async function initPlayer() {
        // Добавляем класс для страницы плеера
        document.getElementById('page-content').classList.add('player-page');
        
        // Настраиваем unified-player для полноэкранного режима
        unifiedPlayer.classList.remove('minimized');
        unifiedPlayer.classList.add('maximized');
        unifiedPlayer.classList.add('visible');

        videoPlayer = document.getElementById('video-player');
        videoTitle = document.getElementById('video-title');
        videoMeta = document.getElementById('video-meta');
        descriptionText = document.getElementById('description-text');
        showMoreBtn = document.getElementById('show-more');

        // Инициализируем Plyr
        player = new Plyr(videoPlayer, {
            controls: [
                'play-large', 'play', 'progress', 'current-time', 'mute',
                'volume', 'captions', 'settings', 'pip', 'airplay', 'fullscreen'
            ],
            settings: ['captions', 'quality', 'speed', 'loop']
        });

        if (window.currentVideo) {
            filePath = window.currentVideo;
            videoPlayer.src = filePath;
            try {
                loadVideoMetadata(filePath);
                player.source = {
                    type: 'video',
                    sources: [{ src: filePath, type: 'video/mp4' }],
                };
               
                player.on('loadedmetadata', () => {
                    player.play().catch(error => {
                        console.error('Error auto-playing video:', error);
                    });
                });
            } catch (error) {
                console.error('Error loading video:', error);
            }
        }

        // Сохраняем время воспроизведения
        player.on('timeupdate', () => {
            window.currentVideoTime = player.currentTime;
        });
    }

    function cleanup() {
        document.getElementById('page-content').classList.remove('player-page');
        if (player) {
            window.currentVideoTime = player.currentTime;
            window.isVideoPlaying = !player.paused;
            player.destroy();
        }
    }


    async function loadVideo(filePath) {
        videoPlayer.src = filePath;
        try {
            await loadVideoMetadata(filePath);

            player.source = {
                type: 'video',
                sources: [{ src: filePath, type: 'video/mp4' }],
            };
           
            player.on('loadedmetadata', () => {
                player.play().catch(error => {
                    console.error('Error auto-playing video:', error);
                });
            });

        } catch (error) {
            console.error('Error loading video:', error);
        }
    }

    function loadVideoMetadata(filePath) {
        return new Promise((resolve, reject) => {
            ffmpeg.setFfprobePath(ffprobe.path);
            
            ffmpeg.ffprobe(filePath, (err, metadata) => {
                if (err) {
                    console.error('Error reading metadata:', err);
                    reject(err);
                    return;
                }

                try {
                    const videoStream = metadata.streams.find(stream => stream.codec_type === 'video');
                    
                    const title = path.basename(filePath, path.extname(filePath))
                        .replace(/-\d+$/, '')
                        .replace(/_/g, ' ');

                    videoTitle.textContent = title;
                    videoMeta.textContent = metadata.format.format_name || 'Unknown format';
                    descriptionText.textContent = 'No description available';

                    resolve({
                        title: title,
                        format: metadata.format.format_name || 'Unknown format'
                    });
                } catch (error) {
                    console.error('Error processing metadata:', error);
                    reject(error);
                }
            });
        });
    }

    function formatBitrate(bitrate) {
        if (!bitrate) return 'Unknown bitrate';
        return `${Math.round(bitrate / 1000)} kbps`;
    }

    // Инициализация плеера при загрузке страницы
    initPlayer();
    return { cleanup };
})();


File: components\header.js
Content:

const settingsButton = document.getElementById('settings-button');
const logoButton = document.getElementById('logo');
const themeToggle = document.getElementById('theme-toggle');
const searchInput = document.getElementById('search');
const downloadButton = document.getElementById('download-button');

const downloadModal = document.getElementById('download-modal');
const closeBtn = document.querySelector('.close');
const videoUrlInput = document.getElementById('video-url');
const qualitySelect = document.getElementById('quality-select');
const qualitySection = document.getElementById('quality-section');
const checkUrlBtn = document.getElementById('check-url');
const startDownloadBtn = document.getElementById('start-download');
const downloadStatus = document.getElementById('download-status');


let isDragging = false;
let currentX;
let currentY;
let initialX;
let initialY;

function dragStart(e) {
    if (!e.target.classList.contains('player-wrapper')) return;
    
    const container = document.getElementById('unified-player');
    initialX = e.clientX - container.offsetLeft;
    initialY = e.clientY - container.offsetTop;
    isDragging = true;
}
function drag(e) {
    if (!isDragging) return;
    
    e.preventDefault();
    const container = document.getElementById('unified-player');
    currentX = e.clientX - initialX;
    currentY = e.clientY - initialY;

    // Ограничиваем перемещение
    const maxX = window.innerWidth - container.offsetWidth;
    const maxY = window.innerHeight - container.offsetHeight;
    currentX = Math.max(0, Math.min(currentX, maxX));
    currentY = Math.max(0, Math.min(currentY, maxY));

    container.style.left = currentX + "px";
    container.style.top = currentY + "px";
}

function dragEnd() {
    isDragging = false;
}

function setupMinimizedPlayer() {
    const unifiedPlayer = document.getElementById('unified-player');
    const videoPlayer = document.getElementById('video-player');
    const playPauseBtn = document.getElementById('play-pause-btn');
    const expandBtn = document.getElementById('expand-btn');
    const closeBtn = document.getElementById('close-btn');

    if (!window.currentVideo) return;

    // Настройка плеера для минимизированного режима
    unifiedPlayer.classList.remove('maximized');
    unifiedPlayer.classList.add('minimized', 'visible');

    // Восстанавливаем время воспроизведения
    if (window.currentVideoTime) {
        videoPlayer.currentTime = window.currentVideoTime;
    }

    // Восстанавливаем состояние воспроизведения
    if (window.isVideoPlaying) {
        videoPlayer.play();
    }

    // Обработчики для кнопок
    playPauseBtn.onclick = () => {
        if (videoPlayer.paused) {
            videoPlayer.play();
        } else {
            videoPlayer.pause();
        }
    };

    expandBtn.onclick = () => {
        window.appFunctions.loadPage('player');
    };

    closeBtn.onclick = () => {
        unifiedPlayer.classList.remove('visible');
        videoPlayer.pause();
    };

    // Drag and drop functionality
    unifiedPlayer.onmousedown = dragStart;
    document.onmousemove = drag;
    document.onmouseup = dragEnd;
}


function toggleTheme() {
    document.body.classList.toggle('dark-theme');
    localStorage.setItem('dark-theme', document.body.classList.contains('dark-theme'));
}

if (localStorage.getItem('dark-theme') === 'true') {
    document.body.classList.add('dark-theme');
    themeToggle.checked = true;
}

themeToggle.addEventListener('change', toggleTheme);


let activeDownloads = new Map();

function initializeTabs() {
    const tabButtons = document.querySelectorAll('.tab-button');
    if (!tabButtons.length) return; // Exit if elements aren't found

    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            const tabId = button.dataset.tab;
            const tabContent = document.getElementById(`${tabId}-tab`);
            
            // Only proceed if we found the tab content
            if (!tabContent) {
                console.error(`Tab content not found for id: ${tabId}-tab`);
                return;
            }
            
            // Remove active class from all tabs and contents
            document.querySelectorAll('.tab-button').forEach(btn => 
                btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => 
                content.classList.remove('active'));
            
            // Add active class to selected tab and content
            button.classList.add('active');
            tabContent.classList.add('active');
        });
    });
}

document.addEventListener('DOMContentLoaded', initializeTabs);

async function initializeDownloads() {
    try {
        const downloads = await ipcRenderer.invoke('get-active-downloads');
        activeDownloads = new Map(downloads.map(d => [d.id, d]));
        updateActiveDownloadsList();
    } catch (error) {
        console.error('Failed to initialize downloads:', error);
    }
}


document.addEventListener('DOMContentLoaded', initializeDownloads);


ipcRenderer.on('download-update', (event, downloads) => {
    activeDownloads = new Map(downloads.map(d => [d.id, d]));
    updateActiveDownloadsList();
});

ipcRenderer.on('download-finished', (event, downloadId) => {
    const download = activeDownloads.get(downloadId);
    if (download) {
        showFinishedNotification(download);
        activeDownloads.delete(downloadId);
        updateActiveDownloadsList();
    }
});

function showFinishedNotification(download) {
    const status = document.getElementById('download-status');
    status.textContent = `Download completed: ${download.url}`;
    status.className = 'status-success';
}

function updateActiveDownloads() {
    ipcRenderer.invoke('get-active-downloads')
        .then(downloads => {
            activeDownloads = new Map(downloads);
            updateActiveDownloadsList();
        })
        .catch(error => {
            console.error('Failed to update active downloads:', error);
        });
}

function updateActiveDownloadsList() {
    const container = document.getElementById('active-downloads-list');
    container.innerHTML = '';
    
    activeDownloads.forEach((download, id) => {
        const item = createDownloadItemElement(download);
        container.appendChild(item);
    });
}


settingsButton.addEventListener('click', () => {
    ipcRenderer.send('open-settings');
});

logoButton.addEventListener('click', () => {
    if (window.currentVideo) {
        setupMinimizedPlayer();
    }
    ipcRenderer.send('index-videos');
});

searchInput.addEventListener('input', (e) => {
    const searchTerm = e.target.value.toLowerCase();
    const filteredVideos = allVideos.filter(video => 
        path.basename(video).toLowerCase().includes(searchTerm)
    );
    displayVideos(filteredVideos);
});

downloadButton.addEventListener('click', () => {
    downloadModal.style.display = 'block';
    videoUrlInput.focus();
    initializeTabs(); 
});

closeBtn.addEventListener('click', () => {
    downloadModal.style.display = 'none';
    resetModal();
});

window.addEventListener('click', (event) => {
    if (event.target === downloadModal) {
        downloadModal.style.display = 'none';
        resetModal();
    }
});

function resetModal() {
    videoUrlInput.value = '';
    qualitySection.style.display = 'none';
    startDownloadBtn.style.display = 'none';
    checkUrlBtn.style.display = 'block';
    downloadStatus.innerHTML = '';
    downloadStatus.className = '';
}
// Проверка информации о видео
checkUrlBtn.addEventListener('click', async () => {
    const url = videoUrlInput.value.trim();
    if (!url) {
        showStatus('Please enter a valid YouTube URL', 'error');
        return;
    }

    try {
        showStatus('Checking video information...', 'info');
        checkUrlBtn.disabled = true;

        const videoInfo = await ipcRenderer.invoke('get-video-info', url);
        qualitySelect.innerHTML = '';
        const qualities = videoInfo.qualities.video;

        Object.entries(qualities)
            .map(([id, info]) => ({
                id,
                label: `${info.height}p${info.fps > 30 ? info.fps : ''} ${info.dynamic_range}`,
                height: info.height
            }))
            .sort((a, b) => b.height - a.height)
            .forEach(quality => {
                const option = document.createElement('option');
                option.value = quality.id;
                option.textContent = quality.label;
                qualitySelect.appendChild(option);
            });

        qualitySection.style.display = 'block';
        startDownloadBtn.style.display = 'block';
        checkUrlBtn.style.display = 'none';
        showStatus('Select video quality and click Download', 'success');
    } catch (error) {
        showStatus(`Error: ${error.message}`, 'error');
    } finally {
        checkUrlBtn.disabled = false;
    }
});

// Начало загрузки видео
startDownloadBtn.addEventListener('click', async () => {
    const url = videoUrlInput.value.trim();
    const selectedQuality = qualitySelect.value;
    
    try {
        // Блокируем кнопку и показываем статус
        startDownloadBtn.disabled = true;
        const status = document.getElementById('download-status');
        status.textContent = 'Starting download...';
        status.className = 'status-info';
        
        const result = await ipcRenderer.invoke('download-video', {
            videoUrl: url,
            videoFormat: selectedQuality,
            audioFormat: 'bestaudio'
        });
        
        // Обновляем UI после успешной загрузки
        status.textContent = 'Download completed!';
        status.className = 'status-success';
        
        // Переключаемся на вкладку активных загрузок
        document.querySelector('[data-tab="active"]').click();
        
    } catch (error) {
        const status = document.getElementById('download-status');
        status.textContent = `Error: ${error.message}`;
        status.className = 'status-error';
    } finally {
        startDownloadBtn.disabled = false;
    }
});

function showStatus(message, type) {
    downloadStatus.innerHTML = type === 'info' 
        ? `<div class="loading-spinner"></div>${message}`
        : message;
    downloadStatus.className = `status-${type}`;
}


document.querySelectorAll('.tab-button').forEach(button => {
    button.addEventListener('click', () => {
        const tabId = button.dataset.tab;
        
        // Переключаем активную вкладку
        document.querySelectorAll('.tab-button').forEach(btn => 
            btn.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(content => 
            content.classList.remove('active'));
        
        button.classList.add('active');
        document.getElementById(`${tabId}-tab`).classList.add('active');
    });
});

function addDownloadItem(videoInfo) {
    const downloadId = Date.now().toString();
    const downloadItem = createDownloadItemElement(downloadId, videoInfo);
    
    document.getElementById('active-downloads-list').appendChild(downloadItem);
    activeDownloads.set(downloadId, {
        status: 'pending',
        info: videoInfo
    });
    
    return downloadId;
}

function updateDownloadStatus(downloadId, status, progress) {
    const downloadItem = document.querySelector(`[data-download-id="${downloadId}"]`);
    if (downloadItem) {
        downloadItem.className = `download-item status-${status}`;
        const statusText = downloadItem.querySelector('.download-status');
        statusText.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        
        if (status === 'finished') {
            setTimeout(() => {
                downloadItem.remove();
                activeDownloads.delete(downloadId);
            }, 3000);
        }
    }
}

function createDownloadItemElement(download) {
    const div = document.createElement('div');
    div.className = `download-item status-${download.status}`;
    div.dataset.downloadId = download.id;
    
    div.innerHTML = `
        <div class="download-item-header">
            <div class="download-title">${download.url}</div>
            <div class="download-status">${download.status}</div>
        </div>
        <div class="download-progress-container">
            <div class="download-progress-bar"></div>
        </div>
    `;
    
    return div;
}

File: components\video-player-manager.js
Content:
// components/video-player-manager.js
class VideoPlayerManager {
    constructor() {
        this.currentVideo = null;
        this.currentTime = 0;
        this.isPlaying = false;
        this.mainPlayer = null;
        this.floatingPlayer = null;
        this.plyrInstance = null;
    }

    async initMainPlayer(videoElement) {
        try {
            if (this.plyrInstance) {
                this.plyrInstance.destroy();
            }

            this.mainPlayer = videoElement;
            this.plyrInstance = new Plyr(videoElement, {
                controls: [
                    'play-large', 'play', 'progress', 'current-time', 'mute',
                    'volume', 'captions', 'settings', 'pip', 'airplay', 'fullscreen'
                ],
                settings: ['captions', 'quality', 'speed', 'loop']
            });

            this.plyrInstance.on('timeupdate', () => {
                this.currentTime = this.plyrInstance.currentTime;
            });

            if (this.currentVideo) {
                await this.loadVideo(this.currentVideo, this.currentTime);
            }
        } catch (error) {
            console.error('Error initializing main player:', error);
        }
    }

    initFloatingPlayer(videoElement) {
        this.floatingPlayer = videoElement;
        if (this.currentVideo) {
            this.floatingPlayer.src = this.currentVideo;
            this.floatingPlayer.currentTime = this.currentTime;
        }
    }

    async loadVideo(videoPath, startTime = 0) {
        try {
            this.currentVideo = videoPath;
            
            if (this.plyrInstance) {
                this.plyrInstance.source = {
                    type: 'video',
                    sources: [{ src: videoPath, type: 'video/mp4' }]
                };
                
                this.plyrInstance.once('loadedmetadata', () => {
                    this.plyrInstance.currentTime = startTime || this.currentTime;
                    if (this.isPlaying) this.plyrInstance.play();
                });
            }

            if (this.floatingPlayer) {
                this.floatingPlayer.src = videoPath;
                this.floatingPlayer.currentTime = startTime || this.currentTime;
                if (this.isPlaying) this.floatingPlayer.play();
            }
        } catch (error) {
            console.error('Error loading video:', error);
        }
    }

    switchToFloating() {
        if (!this.currentVideo) return;

        if (this.plyrInstance) {
            this.currentTime = this.plyrInstance.currentTime;
            this.isPlaying = !this.plyrInstance.paused;
        }

        const floatingContainer = document.getElementById('floating-player-container');
        if (floatingContainer) {
            floatingContainer.classList.remove('hidden');
            if (this.floatingPlayer) {
                this.floatingPlayer.currentTime = this.currentTime;
                if (this.isPlaying) this.floatingPlayer.play();
            }
        }
    }

    switchToMain() {
        if (!this.currentVideo) return;

        if (this.floatingPlayer) {
            this.currentTime = this.floatingPlayer.currentTime;
            this.isPlaying = !this.floatingPlayer.paused;
            this.floatingPlayer.pause();
        }

        const floatingContainer = document.getElementById('floating-player-container');
        if (floatingContainer) {
            floatingContainer.classList.add('hidden');
        }

        window.appFunctions.loadPage('player');
    }
}

module.exports = VideoPlayerManager;

