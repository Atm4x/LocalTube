Prompt: Analyze the LocalTube folder to understand its structure, purpose, and functionality. 
Follow these steps to study the codebase:

1. Read the README file to gain an overview of the project, its goals, and any setup instructions.

2. Examine the folder structure to understand how the files and directories are organized.

3. Identify the main entry point of the application (e.g., main.py, app.py, index.js) and start analyzing the code flow from there.

4. Study the dependencies and libraries used in the project to understand the external tools and frameworks being utilized.

5. Analyze the core functionality of the project by examining the key modules, classes, and functions.

6. Look for any configuration files (e.g., config.py, .env) to understand how the project is configured and what settings are available.

7. Investigate any tests or test directories to see how the project ensures code quality and handles different scenarios.

8. Review any documentation or inline comments to gather insights into the codebase and its intended behavior.

9. Identify any potential areas for improvement, optimization, or further exploration based on your analysis.

10. Provide a summary of your findings, including the project's purpose, key features, and any notable observations or recommendations.

Use the files and contents provided below to complete this analysis:


README:
README not found.

Folder Structure: LocalTube
.git/ [Ignored .git folder]
.gitignore [Skipped]
app.html [Skipped]
app.js [Skipped]
components/
downloader.js [Skipped]
downloads/
LocalTube_contents.txt [Skipped]
main.js [Skipped]
node_modules/
package-lock.json [Skipped]
package.json [Skipped]
pages/
recommendation.js
styles.css [Skipped]
videoIndexer.js [Skipped]
pages\index.html [Skipped]
pages\index.js [Skipped]
pages\player.html
pages\player.js
pages\settings.html [Skipped]
pages\settings.js [Skipped]
components\floating-player.html [Skipped]
components\header.html [Skipped]
components\header.js [Skipped]
components\video-player-manager.js [Skipped]


.git/ [Ignored .git folder]

File: recommendation.js
Content:
class RecommendationSystem {
    constructor() {
        this.watchHistory = new Map();
        this.lastWatched = [];
        this.MAX_HISTORY = 50;
    }

    extractKeywords(filename) {
        if (!filename) return [];
        // Очищаем имя файла от расширения и специальных символов
        return filename
            .replace(/\.[^/.]+$/, "") // убираем расширение
            .toLowerCase()
            .replace(/[^\w\s]/g, '')
            .split(/\s+/)
            .filter(word => word.length > 2);
    }

    calculateSimilarity(currentVideo, candidateVideo) {
        let score = 0;
        
        // Сравниваем ключевые слова из названий
        const keywords1 = this.extractKeywords(currentVideo.title);
        const keywords2 = this.extractKeywords(candidateVideo.title);
        
        if (keywords1.length && keywords2.length) {
            const commonWords = keywords1.filter(word => keywords2.includes(word));
            score += (commonWords.length * 2) / (keywords1.length + keywords2.length);
        }

        // Учитываем длительность, если она доступна
        if (currentVideo.duration && candidateVideo.duration) {
            const durationDiff = Math.abs(currentVideo.duration - candidateVideo.duration);
            const maxDuration = Math.max(currentVideo.duration, candidateVideo.duration);
            score += 1 - (durationDiff / maxDuration);
        }

        // Учитываем историю просмотров
        const watchCount = this.watchHistory.get(candidateVideo.path) || 0;
        score += Math.min(watchCount, 5) * 0.1;

        return score;
    }

    updateWatchHistory(videoPath) {
        this.watchHistory.set(videoPath, (this.watchHistory.get(videoPath) || 0) + 1);
        this.lastWatched.unshift(videoPath);
        if (this.lastWatched.length > this.MAX_HISTORY) {
            this.lastWatched.pop();
        }
    }

    async getRecommendations(currentVideoPath, allVideos) {
        // Получаем метаданные текущего видео
        const currentMetadata = await this.getVideoMetadata(currentVideoPath);
        
        // Формируем рекомендации
        const recommendations = await Promise.all(
            allVideos
                .filter(videoPath => videoPath !== currentVideoPath)
                .map(async (videoPath) => {
                    const metadata = await this.getVideoMetadata(videoPath);
                    const score = this.calculateSimilarity(
                        { ...currentMetadata, path: currentVideoPath },
                        { ...metadata, path: videoPath }
                    );
                    return { videoPath, metadata, score };
                })
        );

        return recommendations
            .sort((a, b) => b.score - a.score)
            .slice(0, 10);
    }

    async getVideoMetadata(videoPath) {
        return new Promise((resolve) => {
            ffmpeg.ffprobe(videoPath, (err, metadata) => {
                if (err) {
                    resolve({
                        title: path.basename(videoPath, path.extname(videoPath))
                            .replace(/-\d+$/, '')
                            .replace(/_/g, ' '),
                        duration: 0,
                        description: 'No description available',
                        views: Math.floor(Math.random() * 1000) // Пример для демонстрации
                    });
                    return;
                }

                resolve({
                    title: metadata.format.tags?.title || path.basename(videoPath, path.extname(videoPath))
                        .replace(/-\d+$/, '')
                        .replace(/_/g, ' '),
                    duration: parseInt(metadata.format.duration) || 0,
                    description: metadata.format.tags?.comment || 'No description available',
                    views: parseInt(metadata.format.tags?.views) || Math.floor(Math.random() * 1000)
                });
            });
        });
    }
}


module.exports = RecommendationSystem;

File: pages\player.html
Content:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LocalTube - Video Player</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdn.plyr.io/3.6.8/plyr.css">
</head>
<body>

    <main class="main-player">
        <div class="video-container">
            <div class="video-info">
                <h1 id="video-title"></h1>
                <div id="video-meta"></div>
                <div class="actions">
                    <button id="like-button">Лайк</button>
                    <button id="dislike-button">Дизлайк</button>
                    <button id="share-button">Поделиться</button>
                </div>
                <div id="video-description">
                    <p id="description-text"></p>
                    <button id="show-more">Показать больше</button>
                </div>
            </div>
        </div>
        <div class="recommendations">
            <h2>Рекомендуемые видео</h2>
            <div id="video-list" class="video-list"></div>
        </div>
    </main>

    <script src="https://cdn.plyr.io/3.6.8/plyr.polyfilled.js"></script>
    <script src="player.js"></script>
</body>
</html>


File: pages\player.js
Content:


(function() {
    console.log("Player page loaded");

    let videoPlayer, videoTitle, videoMeta, descriptionText, showMoreBtn, player;
    const unifiedPlayer = document.getElementById('unified-player');

    async function updateRecommendations() {
        if (!window.currentVideo) return;
    
        // Получаем список всех видео
        ipcRenderer.send('index-videos');
        ipcRenderer.once('video-list', async (event, videos) => {
            const recommendations = await recommendationSystem.getRecommendations(
                window.currentVideo,
                videos
            );
            displayRecommendations(recommendations);
        });
    }

    function displayRecommendations(recommendations) {
        const container = document.getElementById('video-list');
        container.innerHTML = '';
    
        recommendations.forEach(({ videoPath, metadata }) => {
            const recommendationItem = document.createElement('div');
            recommendationItem.className = 'recommendation-item';
    
            const thumbnailContainer = document.createElement('div');
            thumbnailContainer.className = 'recommendation-thumbnail';
    
            // Загружаем превью
            ipcRenderer.invoke('get-video-thumbnail', videoPath).then(thumbnailPath => {
                const img = document.createElement('img');
                img.src = thumbnailPath;
                thumbnailContainer.appendChild(img);
            });
    
            const infoContainer = document.createElement('div');
            infoContainer.className = 'recommendation-info';
    
            const title = document.createElement('div');
            title.className = 'recommendation-title';
            title.textContent = metadata.title;
    
            const description = document.createElement('div');
            description.className = 'recommendation-description';
            description.textContent = metadata.description;
    
            const views = document.createElement('div');
            views.className = 'recommendation-views';
            views.textContent = `${metadata.views.toLocaleString()} views`;
    
            infoContainer.appendChild(title);
            infoContainer.appendChild(description);
            infoContainer.appendChild(views);
    
            recommendationItem.appendChild(thumbnailContainer);
            recommendationItem.appendChild(infoContainer);
    
            recommendationItem.addEventListener('click', () => {
                window.currentVideo = videoPath;
                window.globalPlayer.source = {
                    type: 'video',
                    sources: [{ src: videoPath, type: 'video/mp4' }]
                };
                loadVideoMetadata(videoPath);
                recommendationSystem.updateWatchHistory(videoPath);
            });
    
            container.appendChild(recommendationItem);
        });
    }

    async function initPlayer() {
        
        // Добавляем класс для страницы плеера
        document.getElementById('page-content').classList.add('player-page');
        
        document.removeEventListener('mousemove', dragPlayer);
        document.removeEventListener('mouseup', dragPlayerEnd);
        

        // Настраиваем unified-player для полноэкранного режима
        unifiedPlayer.classList.remove('minimized');
        unifiedPlayer.classList.add('maximized');
        unifiedPlayer.classList.add('visible');

        videoPlayer = document.getElementById('video-player');
        videoTitle = document.getElementById('video-title');
        videoMeta = document.getElementById('video-meta');
        descriptionText = document.getElementById('description-text');
        showMoreBtn = document.getElementById('show-more');

        // Проверяем существует ли уже плеер
        if (!window.globalPlayer) {
            // Инициализируем Plyr только если его еще нет
            window.globalPlayer = new Plyr(videoPlayer, {
                controls: [
                    'play-large', 'play', 'progress', 'current-time', 'mute',
                    'volume', 'captions', 'settings', 'pip', 'airplay', 'fullscreen'
                ],
                settings: ['captions', 'quality', 'speed', 'loop'],
                tooltips: { controls: true, seek: true }
            });
        }
        if (window.playerState) {
            window.playerState.isMinimized = false;
        }
        if (window.currentVideo) {
            // Проверяем, не совпадает ли текущий источник с новым
            if (window.currentVideoSource === window.currentVideo) {
                console.log('Same video, skipping...');
                return;
            }
            filePath = window.currentVideo;
            try {
                loadVideoMetadata(filePath);
                window.globalPlayer.source = {
                    type: 'video',
                    sources: [{ src: filePath, type: 'video/mp4' }],
                };
                recommendationSystem.updateWatchHistory(window.currentVideo);
                await updateRecommendations();
                window.currentVideoSource = window.currentVideo;
               
                window.globalPlayer.on('loadedmetadata', () => {
                    window.globalPlayer.play().catch(error => {
                        console.error('Error auto-playing video:', error);
                    });
                });
            } catch (error) {
                console.error('Error loading video:', error);
            }
        }
    }

    function cleanup() {
        document.getElementById('page-content').classList.remove('player-page');
        if (player) {
            window.currentVideoTime = player.currentTime;
            window.isVideoPlaying = !player.paused;
            player.destroy();
        }
    }


    async function loadVideo(filePath) {
        videoPlayer.src = filePath;
        try {
            await loadVideoMetadata(filePath);

            player.source = {
                type: 'video',
                sources: [{ src: filePath, type: 'video/mp4' }],
            };
           
            player.on('loadedmetadata', () => {
                player.play().catch(error => {
                    console.error('Error auto-playing video:', error);
                });
            });

        } catch (error) {
            console.error('Error loading video:', error);
        }
    }

    function loadVideoMetadata(filePath) {
        return new Promise((resolve, reject) => {
            ffmpeg.setFfprobePath(ffprobe.path);
            
            ffmpeg.ffprobe(filePath, (err, metadata) => {
                if (err) {
                    console.error('Error reading metadata:', err);
                    reject(err);
                    return;
                }

                try {
                    const videoStream = metadata.streams.find(stream => stream.codec_type === 'video');
                    
                    const title = path.basename(filePath, path.extname(filePath))
                        .replace(/-\d+$/, '')
                        .replace(/_/g, ' ');

                    videoTitle.textContent = title;
                    videoMeta.textContent = metadata.format.format_name || 'Unknown format';
                    descriptionText.textContent = 'No description available';

                    resolve({
                        title: title,
                        format: metadata.format.format_name || 'Unknown format'
                    });
                } catch (error) {
                    console.error('Error processing metadata:', error);
                    reject(error);
                }
            });
        });
    }

    function formatBitrate(bitrate) {
        if (!bitrate) return 'Unknown bitrate';
        return `${Math.round(bitrate / 1000)} kbps`;
    }

    // Инициализация плеера при загрузке страницы
    initPlayer();
    return { cleanup };
})();


